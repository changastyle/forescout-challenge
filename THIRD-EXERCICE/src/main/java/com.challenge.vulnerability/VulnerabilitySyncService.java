package com.challenge.vulnerability;

import lombok.Getter;
import lombok.Setter;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class VulnerabilitySyncService {

  // 1 - SIMULATION OF LOCAL DATABASE:
  private final Map<String, Vulnerability> localDatabase = new ConcurrentHashMap<>();

  // 2 - STATUS OF LAST VERSION IN REMOTE SERVICE:
  @Getter
  private final Map<String, String> remoteStateCache = new ConcurrentHashMap<>();

  @Setter
  private RemoteService remoteService = new RemoteService();

  public boolean syncVulnerabilities() {
    boolean ok = false;

    List<Vulnerability> toSync = new ArrayList<>();

    // 3 - COMPARE LOCAL VERSION WITH SENT:
    for (Vulnerability vulnerability : localDatabase.values()) {
      String remoteVersion = remoteStateCache.get(vulnerability.getId());

      // 4 - ONLY ADD TO SYNC LIST IF LOCAL IS DIFERENT THAN REMOTE:
      if (remoteVersion == null || !remoteVersion.equals(vulnerability.getVersion())) {
        toSync.add(vulnerability);
      }
    }

    // 5 - IF THERE IS VULNERABILITIES TO SYNC:
    if (!toSync.isEmpty()) {
      // 6 - SEND TO THE REMOTE
      boolean success = remoteService.sendBatch(toSync);
      if (success) {
        // 7 - UPDATE THE STATUS OF LOCAL IF SUCCESS:
        toSync.forEach(v -> remoteStateCache.put(v.getId(), v.getVersion()));
        ok = true;
      }
    }

    //  8 - IF THERE IS NOTHING TO SEND:
    if (toSync.isEmpty()) {
      ok = false;
    }

    return ok;
  }
  // 10 -  ADD OR UPDATE VULNERABILITIES TO LOCAL
  public void updateLocalDatabase(Vulnerability vulnerability) {
    localDatabase.put(vulnerability.getId(), vulnerability);
  }

  public void deleteVulnerability(String id) {
    localDatabase.remove(id);

    remoteStateCache.remove(id);
  }
}
