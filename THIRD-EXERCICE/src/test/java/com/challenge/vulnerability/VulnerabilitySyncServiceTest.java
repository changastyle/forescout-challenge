package com.challenge.vulnerability;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;


public class VulnerabilitySyncServiceTest {

  private VulnerabilitySyncService syncService;
  private RemoteService remoteService;

  @BeforeEach
  public void setUp() {
    remoteService = new RemoteService();
    syncService = new VulnerabilitySyncService();
    syncService.setRemoteService(remoteService);
  }

  @Test
  public void testSendUpdatedVulnerabilities() {

    // 1 - ADD VULNERABILITY TO LOCAL DB:
    syncService.updateLocalDatabase(new Vulnerability("1", "v1", "data-1"));

    // 2 - INITIAL SYNC:
    boolean result = syncService.syncVulnerabilities();  // Se espera que esta sincronización envíe la vulnerabilidad

    // 3 - VERIFY SUCCESS SYNC:
    assertTrue(result);
  }
  @Test
  public void testSendMultipleVulnerabilities() {
    // 1 - ADD MULTIPLE VULNERABILITIES TO THE LOCAL DATABASE:
    syncService.updateLocalDatabase(new Vulnerability("1", "v1", "data-1"));
    syncService.updateLocalDatabase(new Vulnerability("2", "v1", "data-2"));
    syncService.updateLocalDatabase(new Vulnerability("3", "v1", "data-3"));

    // 2 -  CALL THE SYNCVULNERABILITIES TO SYNC LOCAL VULNERABILITIES WITH THE REMOTE SERVICE:
    boolean result = syncService.syncVulnerabilities();

    // 3 -  SYNC OPERATION SHOULD BE SUCCESSFUL:
    assertTrue(result);
  }

  @Test
  public void testSyncWithNewVulnerabilities() {
    // 1 - ADD TWO NEW VULNERABILITIES TO THE LOCAL DATABASE:
    syncService.updateLocalDatabase(new Vulnerability("1", "v1", "data-1"));
    syncService.updateLocalDatabase(new Vulnerability("2", "v1", "data-2"));

    // 2 -  CALL THE SYNCVULNERABILITIES TO SYNC LOCAL VULNERABILITIES WITH THE REMOTE SERVICE:
    boolean result = syncService.syncVulnerabilities();

    // 3 -  SYNC OPERATION SHOULD BE SUCCESSFUL:
    assertTrue(result);

    // 4 - VERIFY THAT VULNERABILITIES HAVE BEEN UPDATED IN THE REMOTE SERVICE:
    assertEquals("v1", syncService.getRemoteStateCache().get("1"));
    assertEquals("v1", syncService.getRemoteStateCache().get("2"));
  }

  @Test
  public void testSyncAfterVulnerabilityUpdate() {

    // 1 - ADD A VULNERABILITY TO THE LOCAL DATABASE WITH VERSION V1:
    syncService.updateLocalDatabase(new Vulnerability("1", "v1", "data-1"));

    // 2 - INITIAL SYNC:
    syncService.syncVulnerabilities();

    // 3 -  UPDATE THE VULNERABILITY - CHANGING THE VERSION TO V2
    syncService.updateLocalDatabase(new Vulnerability("1", "v2", "data-1-updated"));

    // 4 -  SYNC OPERATION SHOULD BE SUCCESSFUL:
    boolean result = syncService.syncVulnerabilities();
    assertTrue(result);

    //  5 - VERIFY THAT THE REMOTE VERSION WAS UPDATED SUCCESFULLY IN THE REMOTE:
    assertEquals("v2", syncService.getRemoteStateCache().get("1"));
  }

  @Test
  public void testSyncAfterVulnerabilityDeletion() {

    // 1 - ADD A VULNERABILITY TO THE LOCAL DB WITH ID "1" AND VERSION "v1"
    syncService.updateLocalDatabase(new Vulnerability("1", "v1", "data-1"));

    // 2 - INITIAL SYNC:
    boolean firstSyncSuccess = syncService.syncVulnerabilities();
    assertTrue(firstSyncSuccess);

    // 3 - DELETE VULNERABILITY WITH ID "1":
    syncService.deleteVulnerability("1");

    // 4 - SYNF AFTER DELETE, SHOULD NOT BE SENT:
    boolean secondSyncSuccess = syncService.syncVulnerabilities();
    assertFalse(secondSyncSuccess);

    // 5 - VERIFY THAT THE DELETED VULNERABILITY IS NOT IN THE REMOTE:
    assertNull(syncService.getRemoteStateCache().get("1"));
  }


  @Test
  public void testSyncMultipleVulnerabilities() {

    // 1 - ADD MULTIPLE VULNERABILITIES TO THE LOCAL DB:
    syncService.updateLocalDatabase(new Vulnerability("1", "v1", "data1"));
    syncService.updateLocalDatabase(new Vulnerability("2", "v1", "data2"));
    syncService.updateLocalDatabase(new Vulnerability("3", "v1", "data3"));

    // 2 - SYNC IN BATCH MODE:
    boolean result = syncService.syncVulnerabilities();
    assertTrue(result);

    // 3 - VERIFY THAT ALL VULNERABILITIES ARE IN THE REMOTE:
    assertEquals("v1", syncService.getRemoteStateCache().get("1"));
    assertEquals("v1", syncService.getRemoteStateCache().get("2"));
    assertEquals("v1", syncService.getRemoteStateCache().get("3"));
  }

  @Test
  public void testSyncNoChanges() {
    // 1 - ADD A VULNERABILITY TO THE LOCAL DB:
    syncService.updateLocalDatabase(new Vulnerability("1", "v1", "data1"));

    // 2 - INITIAL SYNC:
    syncService.syncVulnerabilities();

    // 3 - ATTEMPT TO SYNC AGAING WITH NO CHANGES - NOTHING SHOULD BE SENT
    boolean result = syncService.syncVulnerabilities();
    assertFalse(result);

    // 4 - VERIFY THAT THE REMOTE STATE WITH NO CHANGES
    assertEquals("v1", syncService.getRemoteStateCache().get("1"));
  }

  @Test
  public void testSyncFailure() {
    // 1 - SIMULATE THAT REMOTE SERVICE FAIL
    syncService.setRemoteService(new RemoteServiceFailure());  // Implementa una clase RemoteServiceFailure que simule el fallo

    // 2 - ADD VULNERABILITY:
    syncService.updateLocalDatabase(new Vulnerability("1", "v1", "data1"));

    // 3 - TRY TO SYNC - SHOULD FAIL
    boolean result = syncService.syncVulnerabilities();
    assertFalse(result, "La sincronización debe fallar si el servicio remoto no responde correctamente");
  }

}
